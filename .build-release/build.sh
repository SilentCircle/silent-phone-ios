#!/bin/bash

###############  D O C U M E N T A T I O N   F O R   U S E R S  ###############
#
# * This script will happily run with without any arguments or environment
#   variables and generate an unsigned xcode archive. However, if you provide
#   the following, extra things will happen:
#
#   - If BUILD_APP_ARCHS is defined, its value is passed to xcode as ARCHS;
#     the default is "i386 x86_64 armv7 arm64". This list is scanned; each of
#     the required corresponding SDKs is built; if there are multiple SDKs,
#     lipo is used to append the SDK-specific libraries into "fat" libraries.
#
#   - If BUILD_CONFIGURATION is defined, its value is passed to xcode; known
#     valid values: Debug|Release|Veracode. If undefined, we force "Debug".
#     xcodebuild's default is "Release". These names *are* case sensitive.
#     If "Veracode", Debug is implied, and attempts to configure any of the
#     other IPAs described below are ignored.
#
#   - If ADHOC_ENTITLEMENTS_PATH is the path to an entitlements plist
#     and ADHOC_EXPORT_OPTIONS_PATH is the path to an export options plist
#     and ADHOC_SIGNING_ID is the numeric key value from the keychain,
#     then an ad-hoc IPA will be exported.
#
#   - If ENTER_ENTITLEMENTS_PATH is the path to an entitlements plist
#     and ENTER_EXPORT_OPTIONS_PATH is the path to an export options plist
#     and ENTER_SIGNING_ID is the numeric key value from the keychain,
#     then an enterprise IPA will be exported.
#
#   - If STORE_ENTITLEMENTS_PATH is the path to an entitlements plist
#     and STORE_EXPORT_OPTIONS_PATH is the path to an export options plist
#     and STORE_SIGNING_ID is the numeric key value from the keychain,
#     then a store IPA will be exported suitable for upload to Apple.
#
#   - If BUILD_OPTIONS is defined, those options will be specified on all the
#     xcodebuild steps. Note this overrides custom options provided by default
#     when BUILD_CONFIGURATION is defined as Veracode.
#
#   - If BUILD_OPTIONS_xxxxx is defined, those options will be specified on
#     the xxxxx project xcodebuild step. Current project names are sqlcipher,
#     polar_ssl, werner_zrtp, cocoalumberjack, and VoipPhone.
#
#   - If GCC_PREPROCESSOR_DEFINITIONS_VoipPhone is defined the options will
#     be appended to the GCC_PREPROCESSOR_DEFINITIONS for the VoipPhone build.
#
#   - If EXEC_BEFORE_xxxx or EXEC_AFTER_xxxx is defined, its contents will
#     be inserted in this script's stream before or after the corresponding
#     project xcodebuild step. Project names are as for BUILD_OPTIONS_xxxx.
#     Execution is echoed to the log. This is intended to support using arms-
#     length tools such as Fortify; use of it to alter the behavior of this
#     script is unsupported.

#########  D O C U M E N T A T I O N   F O R   M A I N T A I N E R S  #########
#
# * This script is based on iosBuild.sh and SilentTextBuild.sh circa 2015-07-06
#   combining the former's log verbosity and intermediate product preservation
#   with the latter's configurability and default xcarchive cleanliness.
#
# * This aborts without finishing if it fails to build a git submodule or the
#   unsigned archive, since finishing is more dangerous than helpful in that
#   scenario. Otherwise, it counts errors and returns 0 if none else 1.
#
# * This variant maintains all its ancestors' conventions with respect to log
#   output format, so iosPublishLogs.sh can reformat its log into html.
#
# * In an pinch, add --no-strict to codesign --verify steps by setting in the
#   environment  CODESIGN_VERIFY=NOSTRICT .
#
# * This version supports both axolotlzrtp and its intended replacement libzina.
#   Eventually axolotlzrtp support will be removed.
#
# * To track down mismatched ' " } etc., temporarily replace "^#:#" with "    ".


####################  U T I L I T Y   F U N C T I O N S  ######################

# Utility function to print boxed text. Argument(s) can contain embedded "\n".
# Note the script that translates this log into html recognizes these boxes, as
# well as lines beginning with "! ", "? " and "+ " (bash -x output).
# Note we'd emit markdown syntax but it wants to make documents, not log files.
#:# echo 'Defining function echo_in_box()'
function echo_in_box()
{
  local IFS=''
  printf "\n"
  printf "$*\n" | \
    awk '{t[++x]=" "$0" "; if ((l=length(t[x]))>w){w=l}} END{for (i=1;i<=w;++i){s=s"-"}; print "."s"."; for(i=1;i<=x;++i){printf "!%-*s!\n",w,t[i]}; print "'\''"s"'\''"}'
  printf "\n"
}

# Utility function to abort the script, printing a message.
# When composing error messages passed to this function, keep in mind that:
# 1) This leaves errorCount.txt containing "Build Aborted".
# 2) The index generated by iosPublishLogs shows this message as a tooltip.
#:# echo 'Defining function failed()'
function failed()
{
  local error=${1:-Undefined error}
  echo "? Failed: $error" >&2
  exit 1
}


# Utility function to check for an error status.
#:# echo 'Defining function check_status()'
function check_status()
{
  local status="$1"

  if [ $status -ne 0 ]
  then
      failed "$status"
  fi
}


# Utility function to get the value of Xcode's VALID_ARCHS for an SDK. Uses a
# rather awkward trick: provokes and parses an error message that mentions the
# value. If you find a clean way to get Xcode values, please upgrade this code!
#:# echo 'Defining function get_sdk_archs()'
function get_sdk_archs()
{
  xcodebuild -sdk $1 ARCHS=provokerr 2>/dev/null \
  | awk -F= '/VALID_ARCHS/{x=$NF; gsub(/[^-_ A-Za-z0-9]/,"",x); print x}'
}

# Utility function to install a library or (if multiple SDKs) make a fat library
# Note: accessing array BUILD_SDKS without {[]} accesses its 0th element.
function post_library()
{
  local libfile="$1"
  local srcbase="$2"
  if [[ ${#BUILD_SDKS[@]} -lt 2 ]]
  then
    local source="$srcbase$BUILD_SDKS/$libfile"
    echo "! Copying $BUILD_PRETTY_SDKLIST $libfile to libs/:"
    cp -v "$source" $BUILD_BASE/libs/ || failed "Cannot install $source"
  else
    local pathlist=()   # list with full paths
    for sdk in ${BUILD_SDKS[@]}
    do
      pathlist+=("$srcbase$sdk/$libfile")
    done
    echo "! lipo'ing the $BUILD_PRETTY_SDKLIST ${libfile} files into a fat binary in libs/:"
    xcrun lipo ${pathlist[@]} -create -output "$BUILD_BASE/libs/$libfile" \
     || failed "Cannot lipo ${libfile} files"
  fi
}


#:# echo 'Defining function handle_xcodebuild_result()'
function handle_xcodebuild_result()
{
  local errcode="$1"
  local project="$2"
  local logfile="$3"
  local errfail="$4"
  if [ $errcode -ne 0 ]
  then
    ((errorCount++))
    echo "? xcodebuild $project failed, code $errcode" >&2
    echo "! Log file: $logfile"
    if   grep -q -F ': fatal error: ' $logfile
    then
      echo '! Last log line containing the string ": fatal error: ":'
      grep -F ': fatal error: ' $logfile | tail -n1 | sed 's/^/    /'
    elif grep -q 'Command .* failed with exit code' $logfile
    then
      echo '! Last log line matching "Command .* failed with exit code":'
      grep 'Command .* failed with exit code' $logfile | tail -n1 | sed 's/^/    /'
    else
      echo '! Last 20 log lines:'
      tail -n20 $logfile | sed 's/^/    /'
    fi
    if [ "$errfail" == 'ERROR_IS_FATAL' ]
    then
      failed "xcodebuild $project gave error $errcode."
    fi
  else
    echo "xcodebuild $project succeeded; last 3 lines of ${logfile}:"
    tail -n3 $logfile | sed 's/^/    /'
  fi
}


#:# echo 'Defining function handle_codesign_result()'
function handle_codesign_result()
{
  local errcode="$1"
  local action="$2"
  if [ $errcode -ne 0 ]
  then
    ((errorCount++))
    echo "? $action failed, code $errcode" >&2
  else
    echo "$action succeeded"
  fi
}


#:# echo 'Defining function verify_architectures()'
function verify_architectures()
{
  local binary="$1"
  local type="$2"
  local wanted="$3"
  local handling=$4

  local entity=$(basename "$1")
  local has=$(xcrun lipo -info "$binary" | sed "s/.*:.*: //")

  echo "! Verifying $entity ${type}:"
  if xcrun lipo "$binary" -verify_arch $wanted
  then
    echo "$entity $type has architectures $has."
  else
    if [ "$handling" == "WARNING" ]
    then
      echo "? $entity $type wants architectures $2 has $has; continuing"
    else
      failed "$entity $type wants architectures $2 has $has."
    fi
  fi
}


#################  G L O B A L   I N I T I A L I Z A T I O N  #################


# The following counts errors that make the script's products useless, but
# are not severe enough to abort its execution entirely.  Finishing execution
# sometimes provides clues to the reason for an otherwise obscure error.
errorCount=0

# iosPublishLogs.sh puts errorCount.txt content into a link title; normally that
# will be Errors:N but in case execution aborts before we have an accurate error
# count, set a default here:
echo 'Build Aborted' >| errorCount.txt



# A way to force an absolute path
BUILD_BASE=`pwd`

# Where to find oddball tools that are supplied by the build environment:
TOOL_BASE=`dirname "$BUILD_BASE"`

# Where the submodules are found
SUBMODULE_BASE=$BUILD_BASE"/libs"

# Tool to adjust contents of Plists.
PlistBuddy=/usr/libexec/PlistBuddy



echo_in_box 'Describing this script and its tools:'
(ls -FTl "$BASH_SOURCE"; ls -FTlL "$BASH_SOURCE") | sort -ru
echo
(ls -FTl "$PlistBuddy"; ls -FTlL "$PlistBuddy") | sort -ru
echo


echo_in_box 'Checking and describing build configuration and options:'

# Forbid parameters, to catch obsolete invocations
if (( $# != 0 ))
then
  failed "This script does not allow any parameters; $# given."
fi

# Veracode configuration is a shorthand for a Debug configuration that requires
# unusual BUILD_OPTIONS. Those may still be overridden externally if necessary.
if [[ "$BUILD_CONFIGURATION" == Veracode ]]
then
  default_build_options='DEBUG_INFORMATION_FORMAT=dwarf-with-dsym COPY_PHASE_STRIP=NO STRIP_INSTALLED_PRODUCT=NO DEPLOYMENT_POSTPROCESSING=NO GCC_GENERATE_DEBUGGING_SYMBOLS=YES GCC_THUMB_SUPPORT=YES GCC_DEBUGGING_SYMBOLS=FULL GCC_OPTIMIZATION_LEVEL=0'
else
  default_build_options=''
fi

echo '! Showing BUILD_CONFIGURATION:'
echo "    ${BUILD_CONFIGURATION=Debug}"
echo '! Showing BUILD_VERSION_PREFIX and BUILD_NUMBER:'
echo "    '${BUILD_VERSION_PREFIX=}'  '$BUILD_NUMBER'"
echo '! Showing BUILD_APP_ARCHS:'
echo "    ${BUILD_APP_ARCHS=i386 x86_64 armv7 arm64}"
echo '! Showing ADHOC_ENTITLEMENTS_PATH:'
echo "    $ADHOC_ENTITLEMENTS_PATH"
echo '! Showing ADHOC_EXPORT_OPTIONS_PATH:'
echo "    $ADHOC_EXPORT_OPTIONS_PATH"
echo '! Showing ENTER_ENTITLEMENTS_PATH:'
echo "    $ENTER_ENTITLEMENTS_PATH"
echo '! Showing ENTER_EXPORT_OPTIONS_PATH:'
echo "    $ENTER_EXPORT_OPTIONS_PATH"
echo '! Showing STORE_ENTITLEMENTS_PATH:'
echo "    $STORE_ENTITLEMENTS_PATH"
echo '! Showing STORE_EXPORT_OPTIONS_PATH:'
echo "    $STORE_EXPORT_OPTIONS_PATH"
echo '! Showing BUILD_OPTIONS:'
echo "    ${BUILD_OPTIONS=$default_build_options}"
echo '! Showing project-specific settings for sqlcipher:'
echo "    build options:    ${BUILD_OPTIONS_sqlcipher=}"
echo "    exec-before hook: ${EXEC_BEFORE_sqlcipher=}"
echo "    exec-after  hook: ${EXEC_AFTER_sqlcipher=}"
echo '! Showing project-specific settings for polar_ssl:'
echo "    build options:    ${BUILD_OPTIONS_polar_ssl=}"
echo "    exec-before hook: ${EXEC_BEFORE_polar_ssl=}"
echo "    exec-after  hook: ${EXEC_AFTER_polar_ssl=}"
echo '! Showing project-specific settings for werner_zrtp:'
echo "    build options:    ${BUILD_OPTIONS_werner_zrtp=}"
echo "    exec-before hook: ${EXEC_BEFORE_werner_zrtp=}"
echo "    exec-after  hook: ${EXEC_AFTER_werner_zrtp=}"
echo '! Showing project-specific settings for cocoalumberjack:'
echo "    build options:    ${BUILD_OPTIONS_cocoalumberjack=}"
echo "    exec-before hook: ${EXEC_BEFORE_cocoalumberjack=}"
echo "    exec-after  hook: ${EXEC_AFTER_cocoalumberjack=}"
echo '! Showing project-specific settings for VoipPhone:'
echo "    build options:    ${BUILD_OPTIONS_VoipPhone=}"
echo "    exec-before hook: ${EXEC_BEFORE_VoipPhone=}"
echo "    exec-after  hook: ${EXEC_AFTER_VoipPhone=}"
echo

# Other symbols shared across mainline functions shall use all-caps * names;
# fix flaws as found.
# BUILD_*_NAME are a single token with no "/" or ".ext" .
# BUILD_*_PATH are absolute paths.

BUILD_ARCHIVE_NAME="SilentPhone"        # our choice
BUILD_ARCHIVE_PATH="$BUILD_BASE/$BUILD_ARCHIVE_NAME.xcarchive"

PROJECT_NAME=SPi3
PROJECT_SCHEME=SPi3
PROJECT_NAME_ENT=EnterprisePhone

BUILD_ADHOC_IPA="$BUILD_BASE/$PROJECT_NAME.ipa"
BUILD_ENTER_IPA="$BUILD_BASE/$PROJECT_NAME_ENT.ipa"
BUILD_STORE_IPA="$BUILD_BASE/$PROJECT_NAME-store.ipa"
BUILD_VCODE_IPA="$BUILD_BASE/SilentPhone_iOS_veracode.ipa"

BUILD_APP_VOIPPHONE_DIR="./"
PROJECT_WORKSPACE="$PROJECT_NAME.xcodeproj/project.xcworkspace"

BUILD_KITS="$BUILD_BASE/kits"
BUILD_KIT_BASE="$BUILD_KITS/base"
BUILD_KIT_ADHOC="$BUILD_KITS/adhoc"
BUILD_KIT_ENTER="$BUILD_KITS/enter"
BUILD_KIT_STORE="$BUILD_KITS/store"
BUILD_KIT_VCODE="$BUILD_KITS/vcode"

# This script cannot choose the application name; it is set by (and should
# probably be read from) xcodebuild settings: PRODUCT_NAME which in turn was
# set from TARGET_NAME.
BUILD_APP_NAME="Silent Phone"

# Centralize product peculiarity configuration
ADHOC_IPA_BUNDLE_ID=com.silentcircle.SilentPhone
ADHOC_IPA_BUNDLE_DISPLAY_NAME="Silent Phone"
ENTER_IPA_BUNDLE_ID=com.silentcircle.enterprisephone
ENTER_IPA_BUNDLE_DISPLAY_NAME="Enterprise Phone"
STORE_IPA_BUNDLE_ID=com.silentcircle.SilentPhone
STORE_IPA_BUNDLE_DISPLAY_NAME="Silent Phone"

STORE_ARCHIVE_PATH="$BUILD_KIT_STORE/store.xcarchive"

# Determine which SDKs we need to build
iph_archs=$(get_sdk_archs iphoneos)
sim_archs=$(get_sdk_archs iphonesimulator)
BUILD_iphoneos_ARCHS=""
BUILD_iphonesimulator_ARCHS=""
for arch in ${BUILD_APP_ARCHS[@]}
do
  if [[ " ${iph_archs[@]} " =~ " $arch " ]] ; then BUILD_iphoneos_ARCHS+="$arch "        ; fi
  if [[ " ${sim_archs[@]} " =~ " $arch " ]] ; then BUILD_iphonesimulator_ARCHS+="$arch " ; fi
done
BUILD_SDKS=()
if [ -n "$BUILD_iphoneos_ARCHS"        ] ; then BUILD_SDKS+=(iphoneos)        ; fi
if [ -n "$BUILD_iphonesimulator_ARCHS" ] ; then BUILD_SDKS+=(iphonesimulator) ; fi


# Cross-check (defaulted) env parameters: forbid creating "fat" libraries
# (ie. having iphonesimulator SDK architectures) when building a store IPA.
if [ -n "$STORE_ENTITLEMENTS_PATH$STORE_EXPORT_OPTIONS_PATH$STORE_SIGNING_ID" ] \
&& [ -n "$BUILD_iphonesimulator_ARCHS" ]
then
  echo "? BUILD_APP_ARCHS env parameter conflicts with STORE_* parameters"
  echo "- BUILD_APP_ARCHS=$BUILD_APP_ARCHS"
  printenv | egrep "^STORE_" | sed "s/^/- /"
  failed "Store IPA must not contain architectures from simulator SDKs"
fi

# Finally, determine and state what we're about to do:
echo_in_box 'Determining Build Plan:'

echo "This build intends to produce:"
echo "   - an unsigned Xcode archive for the iphoneos SDK"

BUILD_PRETTY_SDKLIST=$(echo "${BUILD_SDKS[@]}" | sed 's/ / and /g')
if [[ ${#BUILD_SDKS[@]} -lt 2 ]]
then
  echo "   - developer libraries for the $BUILD_PRETTY_SDKLIST SDK"
else
  echo "   - fat developer libraries for the $BUILD_PRETTY_SDKLIST SDKs"
fi

if [[ "$BUILD_CONFIGURATION" == Veracode ]]
then

  echo "   - an unsigned custom Veracode ipa"
  MAKING_VERACODE_IPA=Yes
  BUILD_CONFIGURATION=Debug

else

  if [ -n "$ADHOC_ENTITLEMENTS_PATH" ] \
  && [ -n "$ADHOC_EXPORT_OPTIONS_PATH" ] \
  && [ -n "$ADHOC_SIGNING_ID" ]
  then
    echo "   - a signed ad-hoc ipa"
    MAKING_ADHOC_IPA=Yes
  fi

  if [ -n "$ENTER_ENTITLEMENTS_PATH" ] \
  && [ -n "$ENTER_EXPORT_OPTIONS_PATH" ] \
  && [ -n "$ENTER_SIGNING_ID" ]
  then
    echo "   - a signed enterprise ipa"
    MAKING_ENTERPRISE_IPA=Yes
  fi

  if [ -n "$STORE_ENTITLEMENTS_PATH" ] \
  && [ -n "$STORE_EXPORT_OPTIONS_PATH" ] \
  && [ -n "$STORE_SIGNING_ID" ]
  then
    echo "   - a signed store ipa"
    MAKING_STORE_IPA=Yes
  fi

fi


###################  M A I N L I N E   F U N C T I O N S   ####################

# This script assumes that is being run for the top of the tree
# Verify by checking for the .git directory
#
#:# echo 'Defining function validate_build_root()'
function validate_build_root()
{
  echo "! BUILD_BASE is '$BUILD_BASE'"
  if [ ! -e .git ]
  then
    failed "Incorrect default directory; build in directory containing .git ."
  fi
}


#:# echo "Defining function describe_keychain()"
function describe_keychain()
{
  echo '! Listing active keychains:'
  security list-keychains

  echo
  echo '! Listing all codeSigning identities on keychain:'
  security find-identity -p codesigning -v
}


#:# echo 'Defining function describe_environment()'
function describe_environment()
{
  echo "! Showing who I am:"
  whoami
  echo 
  echo "! Showing operating system:"
  (sw_vers; sysctl -n kern.boottime; date +}%Z) | \
    awk -F '[\t}]' 'NR==3{$0="\tbooted"} {a=a $2 " "} END{print a}'

  echo
  echo "! Showing available disk space:"
  df -m .
  echo
  echo "! Showing Xcode version:"
  xcodebuild -version
  echo 
  # NOTE: the following string is relied upon by iosPublishLogs.sh:
  echo "! Showing latest repository change:"
  git log --format="%h %an %cd %s" -1
}


#:# echo 'Defining function describe_sdks()'
function describe_sdks()
{
  echo "! Listing available SDKs:"
  xcodebuild -showsdks  
}


#:# echo 'Defining function describe_schemes()'
function describe_schemes()
{
  echo "! Listing available Schemes:"
  find . -name $PROJECT_NAME.xcodeproj
}


#:# echo "Defining function describe_xcode_workspace()"
function describe_xcode_workspace()
{
  xcodebuild -list -workspace "$BUILD_APP_VOIPPHONE_DIR/$PROJECT_WORKSPACE"
}


#:# echo 'Defining function build_prepare()'
function build_prepare()
{
  echo '! Creating "libs" subdirectory:'
  mkdir -v $BUILD_BASE/libs
  echo '! Creating "kits" subdirectory:'
  mkdir -v $BUILD_BASE/kits
}


#:# echo 'Defining function git_submodules()'
function git_submodules()
{
  echo "! Initalizing git submodules:"
  git submodule update --init
  check_status $?
  git submodule status
}


#:# echo 'Defining function sqlcipher_build()'
function sqlcipher_build()
{
  local project_name="sqlcipher"
  local project="$project_name"".xcodeproj"
  local directory=$SUBMODULE_BASE"/sqlcipher"
  local amalgamation_script="amalgamate_""$project_name"".sh"
  local amalgamation_logfile="$BUILD_BASE""/amalgamate_""$project_name"".log"
  local logbase="$BUILD_BASE""/xcodebuild_""$project_name"
  local status=0

  pushd $directory > /dev/null

  echo "! Describing ${project_name}:"
  xcodebuild -list -project $project
  echo

  # The .xcodeproj has an "amalgamation" target for this but its "./configure"
  # step fails (but continues) when run by xcodebuild because xcodebuild alters
  # unknown things that cause gcc to be unable to link a trivial a.out. So, the
  # amalgamation step must be done by extracting the shell script xcodebuild
  # would run and running it outside xcodebuild. This is done as follows:
  #   1) get the .xcodeproj line that's like
  #          shellScript = "<line\nline\nline>";
  #      and translate the quoted string to be a usable script
  #   2) if the last script line is "exit 0", remove it so errors aren't ignored
  #   3) store the script in a file and execute it
  # This could be done by hard-wiring the known script here, but that would fall
  # behind if the script is changed upstream. Better this should start failing!

  awk -f - <<'EOF' sqlcipher.xcodeproj/project.pbxproj >| $amalgamation_script
    /shellScript = .*configure/ {         # find correct line
       sub(/^[^=]*= *"/, "")              # remove text before script lines
       sub(/";$/,        "")              # remove text after script lines
       gsub(/\\\"/,      "\"")            # remove \ before embedded quotes
       n = split($0, a,  "\\\\n")         # break lines into array elements
       if (a[n]=="exit 0") { --n }        # remove line that would force success
       for (i=1;i<=n;++i) { print a[i] }  # emit lines from array elements
    }
EOF

  set -x
  bash -e -x ./$amalgamation_script >| $amalgamation_logfile
  status=$?
  set +x

  if [ $status -ne 0 ]
  then
    echo "? $project_name amalgamation failed, code $status" >&2
    echo "! Log file: $amalgamation_logfile"
    echo '! Last 20 log lines:'
    tail -n20 $amalgamation_logfile | sed 's/^/    /'
    failed "$project_name amalgamation gave error $status."
  fi
  echo "$project_name amalgamation succeeded"
  mv config.log actual_config.log         # preserve from being overwritten

  # Below, explicitly specifying a target has no actual effect; xcodebuild
  # insists on re-running "amalgamation" since it knows about dependencies but
  # not whether they're already generated. After overwriting "config.log" with
  # one with error messages, configure fails, and the "exit 0" removed above
  # fools xcodebuild into continuing.
  for sdk in ${BUILD_SDKS[@]}
  do
    printf "\n! Building $project_name for ${sdk}:\n"
    logfile="${logbase}_${sdk}.log"
    eval archs="\$BUILD_${sdk}_ARCHS"
    set -x
    $EXEC_BEFORE_sqlcipher                                   \
    xcodebuild -verbose                                      \
             -project $project                               \
             -target $project_name                           \
             -sdk $sdk                                       \
             -configuration $BUILD_CONFIGURATION clean build \
             $BUILD_OPTIONS                                  \
             $BUILD_OPTIONS_sqlcipher                        \
             ARCHS="$archs"                                  \
             ONLY_ACTIVE_ARCH=NO                             \
    >| $logfile

    status=$?
    $EXEC_AFTER_sqlcipher
    set +x
    handle_xcodebuild_result $status "$project_name" "$logfile" ERROR_IS_FATAL
  done

  popd > /dev/null
}


#:# echo 'Defining function sqlcipher_post()'
function sqlcipher_post()
{
  post_library libsqlcipher.a "$SUBMODULE_BASE/sqlcipher/build/${BUILD_CONFIGURATION}-"
}


#:# echo 'Defining function sqlcipher_verify()'
function sqlcipher_verify()
{
  local library="$BUILD_BASE/libs/libsqlcipher.a"
  verify_architectures "$library" library "$BUILD_APP_ARCHS" WARNING
}


#:# echo 'Defining function polarssl_build()'
function polarssl_build()
{
  local project_name="polarssl"
  local project="$project_name"".xcodeproj"
  local directory="$SUBMODULE_BASE/polarssl/"
  local logbase="$BUILD_BASE""/xcodebuild_""$project_name"

  pushd $directory  > /dev/null

  echo "! Describing ${project_name}:"
  xcodebuild -list -project $project
  echo

  for sdk in ${BUILD_SDKS[@]}
  do
    echo "! Building $project_name for ${sdk}:"
    logfile="${logbase}_${sdk}.log"
    eval archs="\$BUILD_${sdk}_ARCHS"
    set -x
    $EXEC_BEFORE_polar_ssl                                     \
    xcodebuild -verbose                                        \
               -project $project                               \
               -sdk $sdk                                       \
               -configuration $BUILD_CONFIGURATION clean build \
               $BUILD_OPTIONS                                  \
               $BUILD_OPTIONS_polar_ssl                        \
               ARCHS="$archs"                                  \
               ONLY_ACTIVE_ARCH=NO                             \
    >| $logfile

    local status=$?
    $EXEC_AFTER_polar_ssl
    set +x
    handle_xcodebuild_result $status "$project_name" "$logfile" ERROR_IS_FATAL
  done

  popd > /dev/null
}


#:# echo 'Defining function polarssl_post()'
function polarssl_post()
{
  post_library libpolar_ssl.a "$SUBMODULE_BASE/polarssl/build/${BUILD_CONFIGURATION}-"
}


#:# echo 'Defining function polarssl_verify()'
function polarssl_verify()
{
  local library="$BUILD_BASE/libs/libpolar_ssl.a"
  verify_architectures "$library" library "$BUILD_APP_ARCHS" WARNING
}


#:# echo 'Defining function werner_zrtp_prepare()'
function werner_zrtp_prepare()
{
  # if missing, create link 
  if [ ! -e "$SUBMODULE_BASE/zrtp" ]
  then
    (cd $SUBMODULE_BASE; ln -s zrtpcpp zrtp)
  fi
  # libzina is the new axolotlzrtp, this helps in transition
  if [ ! -e "$SUBMODULE_BASE/axolotlzrtp" ]
  then
    (cd $SUBMODULE_BASE; ln -s libzina axolotlzrtp)
  fi
}


#:# echo 'Defining function werner_zrtp_build()'
function werner_zrtp_build()
{
  local project_name="werner_zrtp"
  local project="$project_name"".xcodeproj"
  local directory="$SUBMODULE_BASE/werner_zrtp"
  local logbase="$BUILD_BASE""/xcodebuild_""$project_name"

  pushd $directory > /dev/null

  echo "! Describing ${project_name}:"
  xcodebuild -list -project $project
  echo

  for sdk in ${BUILD_SDKS[@]}
  do
    echo "! Building $project_name for ${sdk}:"
    logfile="${logbase}_${sdk}.log"
    eval archs="\$BUILD_${sdk}_ARCHS"
    set -x
    $EXEC_BEFORE_werner_zrtp                                   \
    xcodebuild -verbose                                        \
               -project $project                               \
               -sdk $sdk                                       \
               -configuration $BUILD_CONFIGURATION clean build \
               $BUILD_OPTIONS                                  \
               $BUILD_OPTIONS_werner_zrtp                      \
               ARCHS="$archs"                                  \
               ONLY_ACTIVE_ARCH=NO                             \
    >| $logfile

    local status=$?
    $EXEC_AFTER_werner_zrtp
    set +x
    handle_xcodebuild_result $status "$project_name" "$logfile" ERROR_IS_FATAL
  done

  popd > /dev/null
}


#:# echo 'Defining function werner_zrtp_post()'
function werner_zrtp_post()
{
  post_library libwerner_zrtp.a "$SUBMODULE_BASE/werner_zrtp/build/${BUILD_CONFIGURATION}-"
}


#:# echo 'Defining function werner_zrtp_verify()'
function werner_zrtp_verify()
{
  local library="$BUILD_BASE/libs/libwerner_zrtp.a"
  verify_architectures "$library" library "$BUILD_APP_ARCHS" WARNING
}


#:# echo 'Defining function cocoalumberjack_build()'
function cocoalumberjack_build()
{
  local project_name="Lumberjack"
  local project="$project_name"".xcodeproj"
  local directory="$SUBMODULE_BASE/cocoalumberjack"
  local logbase="$BUILD_BASE""/xcodebuild_""$project_name"

  pushd $directory > /dev/null

  echo "! Describing ${project_name}:"
  xcodebuild -list -project $project
  echo

  for sdk in ${BUILD_SDKS[@]}
  do
    echo "! Building $project_name for ${sdk}:"
    logfile="${logbase}_${sdk}.log"
    eval archs="\$BUILD_${sdk}_ARCHS"
    set -x
    $EXEC_BEFORE_cocoalumberjack                               \
    xcodebuild -verbose                                        \
               -project $project                               \
               -target CocoaLumberjack-iOS-Static              \
               -sdk $sdk                                       \
               -configuration $BUILD_CONFIGURATION clean build \
               $BUILD_OPTIONS                                  \
               $BUILD_OPTIONS_cocoalumberjack                  \
               ARCHS="$archs"                                  \
               ONLY_ACTIVE_ARCH=NO                             \
    >| $logfile

    local status=$?
    $EXEC_AFTER_cocoalumberjack
    set +x
    handle_xcodebuild_result $status "$project_name" "$logfile" ERROR_IS_FATAL
  done

  popd > /dev/null
}


#:# echo 'Defining function cocoalumberjack_post()'
function cocoalumberjack_post()
{
  post_library libCocoaLumberjack.a "$SUBMODULE_BASE/cocoalumberjack/build/${BUILD_CONFIGURATION}-"
}


#:# echo 'Defining function cocoalumberjack_verify()'
function cocoalumberjack_verify()
{
  local library="$BUILD_BASE/libs/libCocoaLumberjack.a"
  verify_architectures "$library" library "$BUILD_APP_ARCHS" WARNING
}


# This builds an archive that has what we'll eventually want in our various IPAs.
# This archive would not be accepted by the Apple Store. This is a Safety Feature.
#:# echo "Defining function build_archive()"
function build_archive()
{
  local project="$PROJECT_NAME.xcodeproj"
  local logfile="$BUILD_BASE""/xcodebuild_""$PROJECT_NAME"".log"

  pushd "$BUILD_APP_VOIPPHONE_DIR" > /dev/null

  echo "! Describing ${PROJECT_NAME}:"
  xcodebuild -list -project $project
  echo

  # space separated list of include file header paths

  local hPath=$SUBMODULE_BASE"/zrtpcpp/clients/tivi"
  hPath+=" $SUBMODULE_BASE/zrtpcpp"
  hPath+=" $SUBMODULE_BASE/zrtpcpp/zrtp"
  hPath+=" $SUBMODULE_BASE/polarssl/include"
  hPath+=" $SUBMODULE_BASE/axolotlzrtp"
  hPath+=" $SUBMODULE_BASE/cocoalumberjack/build/$BUILD_CONFIGURATION-iphoneos/include"
  hPath+=" $SUBMODULE_BASE" 	# needed for sqlcipher/sqlite3.h

# The flags below disable code signing. If signing is not forcibly disabled,
# the code is signed automatically by Apple looking up and applying previously
# used credentials cached in undocumented places.
#
#             CODE_SIGN_IDENTITY=""                                  \
#             CODE_SIGNING_REQUIRED=NO                               \

  local gcc_prepro_tmp='$GCC_PREPROCESSOR_DEFINITIONS '
        gcc_prepro_tmp+="$GCC_PREPROCESSOR_DEFINITIONS_VoipPhone"

  echo "! Building ${PROJECT_NAME}:"
  set -x
  $EXEC_BEFORE_VoipPhone                                             \
  xcodebuild -verbose                                                \
             -scheme        $PROJECT_SCHEME                          \
             -sdk           iphoneos                                 \
             -workspace     $PROJECT_WORKSPACE                       \
             -configuration $BUILD_CONFIGURATION clean build archive \
             -archivePath   $BUILD_ARCHIVE_PATH                      \
             CODE_SIGN_IDENTITY=""                                   \
             CODE_SIGNING_REQUIRED=NO                                \
             GCC_PREPROCESSOR_DEFINITIONS="$gcc_prepro_tmp"          \
             $BUILD_OPTIONS                                          \
             $BUILD_OPTIONS_VoipPhone                                \
             HEADER_SEARCH_PATHS="$hPath"                            \
             LIBRARY_SEARCH_PATHS="$BUILD_BASE/libs"                 \
             ARCHS="$BUILD_iphoneos_ARCHS"                           \
             ONLY_ACTIVE_ARCH=NO                                     \
  >| $logfile

  local status=$?
  $EXEC_AFTER_VoipPhone
  set +x
  handle_xcodebuild_result $status "$PROJECT_NAME" "$logfile" ERROR_IS_FATAL

  popd > /dev/null
}


# It would be nice to modify the CFBundleVersion in apple/ios/VoipPhone/VoipPhone-Info.plist
# before building the archive, and let xcodebuild copy in the desired bundle ID. Unfortunately
# a hook (in the .pbxproj file) destroys that value. Therefore this must be called after the
# archive has been built.
#:# echo "Defining function set_build_version()"
function set_build_version()
{
  local archive_plist="$BUILD_ARCHIVE_PATH/Info.plist"
  # BUILD_VERSION_PREFIX - defined by the release engineer in Jenkins build exec shell
  # BUILD_NUMBER from Jenkins
  BUILD_VERSION_ID="$BUILD_VERSION_PREFIX$BUILD_NUMBER"

  echo "! Displaying pre-existing CFBundleVersion and then changing to '$BUILD_VERSION_ID':"

  echo -n 'Pre-existing CFBundleVersion is: '
  /usr/libexec/PlistBuddy -c "Print :ApplicationProperties:CFBundleVersion" $archive_plist

  /usr/libexec/PlistBuddy -c "Set :ApplicationProperties:CFBundleVersion $BUILD_VERSION_ID" $archive_plist

  echo -n 'CFBundleVersion is now set to: '
  /usr/libexec/PlistBuddy -c "Print :ApplicationProperties:CFBundleVersion" $archive_plist
}


# This is parameterized, and the Jenkins workspace contents carefully
# structured, to support building multiple xcarchives.
# Arg1 is the .xcarchive to be verified.
# Arg2 is "signed" if archive signature validity should be verified.
#:# echo "Defining function verify_archive()"
function verify_archive()
{
  local xcarchive="$1"

  echo '! Displaying and checking bundle version:'

  local archivePlist="$xcarchive/Info.plist"
  local bundleVersion=`/usr/libexec/PlistBuddy -c "Print :ApplicationProperties:CFBundleVersion" $archivePlist`
  echo "Archive bundle version: $bundleVersion"

  # Verify the archive has the BUILD_VERSION_ID of the app just built
  if [ "$BUILD_VERSION_ID" != "$bundleVersion" ]
  then
    failed "verify_archive wants version $BUILD_VERSION_ID got $bundleVersion."
  fi

  #  Verify the xcarchive has the wanted hardware architectures
  local archive_app="$xcarchive/Products/Applications/$BUILD_APP_NAME.app"
  local archive_binary="$archive_app/$BUILD_APP_NAME"
  verify_architectures "$archive_binary" xcarchive "$BUILD_iphoneos_ARCHS" ABORT

  echo
  verify_app "$BUILD_APP_NAME.app in archive" "$archive_app" "$2"
}

# Common code to verify an app, displaying its entitlements and signature.
# Arg1 is the entity to be verified, for log messages.
# Arg2 is the path to the .app to verify; may be in a Payload or .xcarchive .
# Arg3 is "signed" if archive signature validity should be displayed/verified;
#      if arg3 is not "signed", signature presence is treated as a fatal error.
#:# echo "Defining function verify_app()"
function verify_app()
{
  local entity="$1"
  local app_path="$2"
  local signed="$3"
  local mpfile="$app_path/embedded.mobileprovision"

  if [ "$signed" == 'signed' ]
  then
    echo "! Displaying details of ${entity}:"
    echo "  Signature:"
    codesign -d --verbose=4 --file-list - "$app_path" 2>&1 | sed 's/^/    /'
    echo
    echo "  Entitlements:"
    codesign -d --entitlements :- "$app_path" 2>&1 | sed 's/^/    /'
    echo
    echo "  Contents of $mpfile of ${entity}:"
    if [ -r "$mpfile" ]
    then
      echo "    Entitlements:"
      security cms -D  -i "$mpfile" | plutil -extract Entitlements xml1 -o - - | sed 's/^/      /'
      echo "    Provisioning Profile:"
      local provName=`awk -F '[<>]' '/<key>Name</          {getline; print $3}' "$mpfile"`
      local provUUID=`awk -F '[<>]' '/<key>UUID</          {getline; print $3}' "$mpfile"`
      local provExDT=`awk -F '[<>]' '/<key>ExpirationDate</{getline; print $3}' "$mpfile"`
      echo "      Name:    $provName"
      echo "      UUID:    $provUUID"
      echo "      Expires: $provExDT"
    else
      echo "    $entity has no embedded.mobileprovision file; this is normal for archives."
    fi
    echo
    echo "! Verifying signature of ${entity}:"
    echo 'Result of "strict" verification:'
    codesign --verify --verbose=4               "$app_path"
    local strict_status=$?
    echo
    echo 'Result of "no-strict" verification:'
    codesign --verify --verbose=4  --no-strict  "$app_path"
    local nostrict_status=$?
    echo
    local status=$strict_status
    if [ $status -ne 0 ] && [ "$CODESIGN_VERIFY" == 'NOSTRICT' ]
    then
      echo 'Applying CODESIGN_VERIFY=NOSTRICT !'
      status=$nostrict_status
    fi
    handle_codesign_result $status "Verifying signature of $entity"
  else
    echo "! Confirming $entity is unsigned:"
    codesign --verify --verbose=4 "$app_path"
    local status=$?
    if [ $status -eq 0 ]
    then
      failed "$entity should be unsigned but is signed."
    fi
  fi
}


# Do not be fooled by the .ipa extension; Veracode wants weird non-IPA content.
#:# echo "Defining function make_veracode_ipa()"
function make_veracode_ipa()
{
  local ipa=$1
  local kit=`echo $2|awk -F/ '{print $NF}'`

  mkdir -p -v $2
  pushd       $2 > /dev/null
  touch $kit-make_ipa_from_archive.began

  local ipa_archive_path="$(pwd)/$kit.xcarchive"
  local logfile="$kit-make_ipa_from_archive.log"
  local arc_app_dir="$BUILD_ARCHIVE_PATH/Products/Applications"
  local arc_sym_dir="$BUILD_ARCHIVE_PATH/dSyms"

  cat <<-EOF
	! Exporting from:
	    $BUILD_ARCHIVE_PATH
	! Producing:
	    $ipa

EOF

  mkdir -v Payload                                            | tee    $logfile
  echo "! Copying $BUILD_APP_NAME.app ..."                    | tee -a $logfile
  cp -piRv "$arc_app_dir/$BUILD_APP_NAME.app"        Payload  >>       $logfile
  echo "! Copying $BUILD_APP_NAME.app.dsym ..."               | tee -a $logfile
  cp -piRv "$arc_sym_dir/$BUILD_APP_NAME.app.dSYM"   Payload  >>       $logfile
  echo "! Zipping Payload ..."                                | tee -a $logfile
  zip -r tmp.zip                                     Payload  >>       $logfile
  echo "! Delivering final product ..."                       | tee -a $logfile
  mv -v tmp.zip "$ipa"                                        | tee -a $logfile

  touch $kit-make_ipa_from_archive.ended
  popd > /dev/null
}


# This is parameterized, and Jenkins workspace contents carefully structured, to
# support building multiple IPAs using the same common technique. It works by
# copying the unsigned archive, modifying its bundle ID if necessary, signing
# it, and finally exporting an IPA from it. The passed-in provisioning profile
# entitlements determine whether an enterprise or ad-hoc IPA is produced.
#   Arg1:    full path of .ipa to create
#   Arg2:    workspace subdirectory in which to do this IPA's work
#   Arg3:    IPA profile name
#   Arg4:    signing ID
#   Arg5:    Entitlements path
#   Arg6:    bundle ID to set, if any, else ''
#   Arg7:    bundle Display Name to set, if any, else ''
#   Arg8:    exportOptionsPlist path
#
#:# echo "Defining function make_ipa_from_archive()"
function make_ipa_from_archive()
{
  local ipa=$1
  local kit=`echo $2|awk -F/ '{print $NF}'`

  mkdir -p -v $2
  pushd       $2 > /dev/null
  touch $kit-make_ipa_from_archive.began

  local ipa_archive_path="$(pwd)/$kit.xcarchive"
  local logfile="$kit-make_ipa_from_archive.log"
  local arc_app="$ipa_archive_path/Products/Applications/$BUILD_APP_NAME.app"
  local export_options_path="$3"
  local signing_id="$4"
  local entitlements_path="$5"


  cat <<-EOF
	! Initially copying from:
	    $BUILD_ARCHIVE_PATH
	! Mutating then exporting from:
	    $ipa_archive_path
	! Finally producing:
	    $ipa

EOF

  # Make a local copy of the unsigned archive
  cp -r "$BUILD_ARCHIVE_PATH" "$ipa_archive_path"

  # If requested, replace the bundle identifier and display name
  if [ -n "$6" ] && [ -n "$7" ]
  then
    echo "! Replacing '$kit' IPA's Bundle Identifier and Display Name:"
    $PlistBuddy -c "Set :CFBundleIdentifier  $6" "$arc_app/Info.plist"
    # SP3 does not have a CFBundleDisplayName add one so it can be modified
    $PlistBuddy -c "Add :CFBundleDisplayName string foo" "$arc_app/Info.plist"
    $PlistBuddy -c "Set :CFBundleDisplayName $7" "$arc_app/Info.plist"

    # hack to test a theory
    #
    if [ "$6" = "com.silentcircle.enterprisephone" ]
    then
      set -x
      local extensionPlist="$arc_app/PlugIns/IntentHandler.appex/Info.plist"
      if [ -f "$extensionPlist" ]
      then
        local extensionBundleId="com.silentcircle.enterprisephone.IntentHandler"
        echo "! Replacing '$kit' extension Bundle Identifier"
        $PlistBuddy -c "Set :CFBundleIdentifier  $extensionBundleId" "$extensionPlist"
      fi
      set +x
    fi
  fi

  # Use codesign to append the entitlements to the program binary.
  # (The signature is supplied to prevent a "code object is not signed" error).
  echo "! Append entitlements to '$kit' archive:"
  codesign -f --verbose=4                      \
           --sign "$signing_id"                \
           --entitlements "$entitlements_path" \
           "$arc_app"

  handle_codesign_result $? "Appending entitlements to '$kit' ipa"

  export_dir_path="$(pwd)/export"

  # Export the ipa from the archive, signing it as we do so.

  echo "! Signing and exporting to '$kit' IPA:"
  set -x
  xcodebuild -verbose                                   \
             -exportArchive                             \
             -archivePath "$ipa_archive_path"           \
             -exportPath  "$export_dir_path"            \
             -exportOptionsPlist "$export_options_path" \
             CODE_SIGN_IDENTITY="$signing_id"           \
  >| $logfile

  local status=$?
  set +x
  handle_xcodebuild_result $status "archive export for '$kit' ipa" "$logfile" TOLERATE_ERROR

  # this is needs to be changed to a search for the ipa
  # mv $export_dir_path/$BUILD_APP_NAME.ipa  $ipa
  mv $export_dir_path/$PROJECT_SCHEME.ipa  $ipa

  touch $kit-make_ipa_from_archive.ended
  popd > /dev/null
}


# This is parameterized, and Jenkins workspace contents carefully structured,
# to support building multiple IPAs.
# $1 - path to IPA file
# $2 - path to kit subdirectory
# $3 - "signed" unless kit should be unsigned
#:# echo "Defining function verify_ipa()"
function verify_ipa()
{
  local ipa=$1
  local kit=`echo $2|awk -F/ '{print $NF}'`

  mkdir -p -v "$2/vfy"
  pushd "$2/vfy" > /dev/null
  touch $kit-verify_ipa.began

  unzip -q "$ipa"
  
  verify_app "$BUILD_APP_NAME.app in '$kit' IPA" "Payload/$BUILD_APP_NAME.app" "$3"

  touch $kit-verify_ipa.ended
  popd > /dev/null
}


#:# echo "Defining function make_store_archive_from_archive()"
function make_store_archive_from_archive()
{
  mkdir -p -v $BUILD_KIT_STORE
  pushd       $BUILD_KIT_STORE > /dev/null
  touch make_store_archive_from_archive.began

  # make a local copy of the archive
  echo "! Copying the archive:"
  cp -R "$BUILD_ARCHIVE_PATH" "$STORE_ARCHIVE_PATH"

  local arc_app="$STORE_ARCHIVE_PATH/Products/Applications/$BUILD_APP_NAME.app"

  # Sign the archive which appends the entitlements to the program binary
  echo "! Forcibly signing the archive:"
  codesign -f --verbose=4 --sign "$STORE_SIGNING_ID" \
           --entitlements "$STORE_ENTITLEMENTS_PATH" \
           "$arc_app"
  handle_codesign_result $? "Signing store archive"

  touch make_store_archive_from_archive.ended
  popd > /dev/null
}


### FOR POSSIBLE FUTURE USE ###
# $1 - compare base's name
# $2 - compare target's name
#:# echo 'Defining function compare_payloads()'
function compare_payloads()
{
  local bKit="$1"
  local dKit="$2"
  local bPath="$1"
  local dPath="$2/vfy"
  local diffOut="$dPath/${bKit}_differences.txt"
  pushd "$BUILD_KITS" > /dev/null

  echo
  echo "! Comparing verified $dKit to $bKit, i.e. these two directories:"
  # ls "rt" options below sort by increasing modification date, so older first
  ls -FLTldrt \
      "$bPath/Payload/$PROJECT_NAME.app" \
      "$dPath/Payload/$PROJECT_NAME.app" \
    | sed 's/^/    /'

  diff -qr \
      "$bPath/Payload/$PROJECT_NAME.app" \
      "$dPath/Payload/$PROJECT_NAME.app" \
    > $diffOut
  if [ $? -lt 2 ]
  then
    diffCount=`grep -c . $diffOut`
    case $diffCount in
    (0)
      echo "  All $dKit kit $PROJECT_NAME.app files are identical to the $bKit kit's."
      ;;
    (1)
      echo "  1 $dKit kit $PROJECT_NAME.app file differs from the $bKit kit's:"
      ;;
    ([2-5])
      echo "  $diffCount $dKit kit $PROJECT_NAME.app files differ from the $bKit kit's:"
      ;;
    (*)
      echo "  WARNING: $diffCount $dKit kit $PROJECT_NAME.app files differ from the $bKit kit's."
      echo "  The full list is in $diffOut. The first 5 are:"
      ;;
    esac
    head -5 $diffOut | sed 's/^/  /'
  else
    echo '? Could not compare kits.'
  fi

  popd > /dev/null
}



echo_in_box 'Validating Build Root:'
validate_build_root
echo

if [ -n "$MAKING_ADHOC_IPA" ] || [ -n "$MAKING_ENTERPRISE_IPA" ] || [ -n "$MAKING_STORE_ARCHIVE" ]
then
  echo_in_box 'Describing Keychain:'
  describe_keychain
fi

echo_in_box 'Describing Environment:'
describe_environment
echo

echo_in_box 'Describing SDKs:'
describe_sdks

echo_in_box 'Describing Schemes:'
describe_schemes
echo

echo_in_box 'Describing Xcode Workspace:'
describe_xcode_workspace

echo_in_box 'Preparing For Build:'
build_prepare
echo

echo_in_box 'Initializing git Submodules:'
git_submodules
echo

echo_in_box 'Building sqlcipher Submodule:'
sqlcipher_build
sqlcipher_post
sqlcipher_verify
echo

echo_in_box 'Building polar_ssl Submodule:'
polarssl_build
polarssl_post
polarssl_verify
echo

echo_in_box 'Building werner_zrtp Submodule:'
werner_zrtp_prepare
werner_zrtp_build
werner_zrtp_post
werner_zrtp_verify
echo

echo_in_box 'Building cocoalumberjack Submodule:'
cocoalumberjack_build
cocoalumberjack_post
cocoalumberjack_verify
echo

echo_in_box 'Building Silent Phone App Archive:'
build_archive

echo_in_box 'Setting Build Version:'
set_build_version
echo

echo_in_box 'Verifying Archive:'
verify_archive "$BUILD_ARCHIVE_PATH" 'unsigned'
echo

if [ $MAKING_VERACODE_IPA ]
then
  echo_in_box 'Making Veracode IPA from Archive:'
  make_veracode_ipa                  \
    "$BUILD_VCODE_IPA"               \
    "$BUILD_KIT_VCODE"
  echo_in_box 'Verifying Veracode IPA:'
  verify_ipa "$BUILD_VCODE_IPA" "$BUILD_KIT_VCODE" ""
fi

if [ $MAKING_ADHOC_IPA ]
then
  echo_in_box 'Making Ad-Hoc IPA from Archive:'
  make_ipa_from_archive              \
    "$BUILD_ADHOC_IPA"               \
    "$BUILD_KIT_ADHOC"               \
    "$ADHOC_EXPORT_OPTIONS_PATH"     \
    "$ADHOC_SIGNING_ID"              \
    "$ADHOC_ENTITLEMENTS_PATH"       \
    "$ADHOC_IPA_BUNDLE_ID"           \
    "$ADHOC_IPA_BUNDLE_DISPLAY_NAME"
  echo_in_box 'Verifying Ad-Hoc IPA:'
  verify_ipa "$BUILD_ADHOC_IPA" "$BUILD_KIT_ADHOC" signed
  echo
fi

if [ $MAKING_ENTERPRISE_IPA ]
then
  echo_in_box 'Making Enterprise IPA from Archive:'
  make_ipa_from_archive              \
    "$BUILD_ENTER_IPA"               \
    "$BUILD_KIT_ENTER"               \
    "$ENTER_EXPORT_OPTIONS_PATH"     \
    "$ENTER_SIGNING_ID"              \
    "$ENTER_ENTITLEMENTS_PATH"       \
    "$ENTER_IPA_BUNDLE_ID"           \
    "$ENTER_IPA_BUNDLE_DISPLAY_NAME" 
  echo_in_box 'Verifying Enterprise IPA:'
  verify_ipa "$BUILD_ENTER_IPA" "$BUILD_KIT_ENTER" signed
  echo
fi

if [ $MAKING_STORE_ARCHIVE ]
then
  echo_in_box 'Making Store Archive from Archive:'
  echo
  make_store_archive_from_archive
  echo
  echo_in_box 'Verifying Store Archive:'
  echo
  verify_archive "$STORE_ARCHIVE_PATH" 'signed'
  echo
fi

if [ $MAKING_STORE_IPA ]
then
  echo_in_box 'Making Store IPA from Archive:'
  make_ipa_from_archive              \
    "$BUILD_STORE_IPA"               \
    "$BUILD_KIT_STORE"               \
    "$STORE_EXPORT_OPTIONS_PATH"     \
    "$STORE_SIGNING_ID"              \
    "$STORE_ENTITLEMENTS_PATH"       \
    "$STORE_IPA_BUNDLE_ID"           \
    "$STORE_IPA_BUNDLE_DISPLAY_NAME"
  echo_in_box 'Verifying Store IPA:'
  verify_ipa "$BUILD_STORE_IPA" "$BUILD_KIT_STORE" signed
  echo
fi


#echo_in_box 'Comparing Verified IPA To Archive:'
#echo
#compare_payloads base ent
#echo


echo_in_box "Build Phase Completed! Errors:$errorCount."

echo "Errors:$errorCount" >| errorCount.txt

exit $[ errorCount > 0 ]
